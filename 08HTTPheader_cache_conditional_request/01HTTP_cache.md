## HTTP 헤더2 - 캐시와 조건부 요청
### 캐시 기본 동작

---

### 캐시가 없을 때
#### 첫 번째 요청

> 웹 브라우저
>
> 요청1
> 
> ---
>
> GET /star.jpg

-->

> 서버
> 
> ---
>
> **start-line**
>
> HTTP/1.1 **200 OK**
>
> ---
>
> **header**
>
> Content-Type: image/jpeg
>
> Content-Length: 34012
>
> ---
>
> **body**
>
> ````text
> lkj123kljoiasudlkjaweioluywlnfdo912u34ljko98udjkl
> ````

<-- star.jpg

1.1M 가정

HTTP 헤더: 0.1M

HTTP 바디: 1.0M

( _**1.1M 전송**_ )

---

### 캐시가 없을 때
#### 두 번째 요청

> 웹 브라우저
>
> 요청2
>
> ---
>
> GET /star.jpg

-->

> 서버
>
> ---
>
> **start-line**
>
> HTTP/1.1 **200 OK**
>
> ---
>
> **header**
>
> Content-Type: image/jpeg
>
> Content-Length: 34012
>
> ---
>
> **body**
>
> ````text
> lkj123kljoiasudlkjaweioluywlnfdo912u34ljko98udjkl
> ````

<-- star.jpg
( _**1.1M 전송2**_ )

- 똑같은 요청을 또 받으면,
- 서버에서는 똑같이 요청을 받아서 응답을 내려주는데
- HTTP 헤더와 바디를 똑같이 맨들어서 1.1M 의 용량을 다시 내려준다
- 그래서 웹 브라우저에서 다시 그린다

---

### 캐시가 없을 때

- 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다


- 인터넷 네트워크는 매우 느리고 비싸다
  - ( 상대적으로 PC 의 메모리나 하드디스크에 비해서... )

- 브라우저 로딩 속도가 느리다


- 느린 사용자 경험

---

### 캐시 적용
#### 첫 번째 요청

> 웹 브라우저
>
> 요청1
>
> ---
>
> GET /star.jpg

-->

> 서버
>
> ---
>
> **start-line**
>
> HTTP/1.1 **200 OK**
>
> ---
>
> **header**
>
> Content-Type: image/jpeg
> 
> **cache-control: max-age=60**
> 
> ( 캐시가 유효한 시간( 초 ) )
>
> Content-Length: 34012
>
> ---
>
> **body**
>
> ````text
> lkj123kljoiasudlkjaweioluywlnfdo912u34ljko98udjkl
> ````

<-- star.jpg

( _**1.1M 전송**_ )

> 브라우저 캐시
> 
> ---
> 
> **60초 유효**
> 
> ( 응답 결과를 캐시에 저장 )

- 최초로 요청을 할때, cache-control 을 설정해두면,
- 브라우저 캐시에 저장해둔다

---

### 캐시 적용
#### 두 번째 요청

> 웹 브라우저
>
> 요청2
>
> ---
>
> GET /star.jpg
> 
> ---
> 
> 캐시 유효 시간 검증

-->


> 브라우저 캐시
>
> ---
>
> **60초 유효**
>
> ( 캐시에서 조회 )

<-- star.jpg

> 서버
> 
> ---
> 
> 네트워크 요청을 아예하지 않음

- 두 번째 요청할때는, 캐시를 먼저 뒤진다.
- 그런데 캐시의 유효한 시간내 값이 있다면 캐시에서 바로 가져온다


- 네트워크를 아예 탈 필요가 없는 것이다

---

### 캐시 적용

- 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.


- 비싼 네트워크 사용량을 줄일 수 있다.


- 브라우저 로딩 속도가 매우 빠르다
  - ( 메모리나 하드디스크에서 바로 불러오는 것이기 때문 )


- 빠른 사용자 경험
  - 들어갔던 웹브라우저를 다시 들어가면 굉장히 빠르게 열리는 이유

---

### 캐시 적용
#### 세 번째 요청 - 캐시 시간 초과

> 웹 브라우저
>
> 요청3
>
> ---
>
> GET /star.jpg
>
> ---
>
> 캐시 유효 시간 검증

-->


> 브라우저 캐시
>
> ---
>
> **60초 초과**
>
> ( 응답 결과를 다시 캐시에 저장 )

> 서버
>
> ---
>
> **start-line**
>
> HTTP/1.1 **200 OK**
>
> ---
>
> **header**
>
> Content-Type: image/jpeg
>
> **cache-control: max-age=60**
>
> ( 캐시가 유효한 시간( 초 ) )
>
> Content-Length: 34012
>
> ---
>
> **body**
>
> ````text
> lkj123kljoiasudlkjaweioluywlnfdo912u34ljko98udjkl
> ````

<-- star.jpg
( _**1.1M 전송**_ )

- 유효시간이 초과되었으면, 당연히 다시 요청을 해야한다
- 요청을 했더니, 서버에서 똑같은 응답을 내려준다


- 이제 받은 데이터로 기존 캐시데이터를 덮어씌운다( 캐시 초기화 )


- 이 과정에서 당연히 네트워크는 1.1M 를 사용한다

---

### 캐시 시간 초과

- 캐시 유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고, 캐시를 갱신한다


- 이때 다시 네트워크 다운로드가 발생한다

> 그런데 다시 다운로드 받을때 동일한데이터라면 데이터가 아깝다
>
> 캐시가 만료되었지만, **클라이언트가 가지고 있는 데이터와 서버가 가지고 있는 데이터가 똑같다면**
> 
> 이 1M 나 되는 데이터를 다시받을 필요가 있을까?
> 
> ---
> 
> 이것을 해결할 수 있는 메커니즘이 다음시간에....