## 검증 헤더와 조건부 요청1

---

### 캐시 시간 초과

- 캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 나타난다


  1. 서버에서 기존 데이터를 변경함
    - ( 진짜 클라이언트의 데이터가 변경이 일어나서 캐시를 갱신해야 할때 )


  2. 서버에서 기존 데이터를 변경하지 않음
    - 변경이 일어나지 않았다면 굳이 다운받아야 하는가...
  
- 이런 의문을 해결하는 것이 검증 헤더이다

---

### 캐시 시간 초과

- 캐시 만료 후에도 서버에서 데이터를 변경하지 않음


- 생각해보면 데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용 할 수 있다
  - 데이터가 변하지 않았기 때문...


- 단 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법 필요

---

### 검증 헤더 추가
#### 첫 번째 요청


> 웹 브라우저
>
> 요청1
>
> ---
>
> GET /star.jpg

-->

> 서버
> 
> **start-line**
>
> HTTP/1.1 **200 OK**
>
> ---
>
> **header**
>
> Content-Type: image/jpeg
> 
> cache-control: max-age=60
> 
> **Last-Modified: 2020년 11월 10일 10:00:00**
> 
> ( 데이터가 마지막에 수정된 시간 : UTC 표기법 )
> 
> Content-Length: 34012
>
> ---
>
> **body**
>
> ````text
> lkj123kljoiasudlkjaweioluywlnfdo912u34ljko98udjkl
> ````

<-- star.jpg

( _**1.1M 전송**_ )

( _**데이터 최종 수정일**_ )

( _**2020년 11월 10일 10:00:00**_ )

---

### 검증 헤더 추가
#### 첫 번째 요청


> 웹 브라우저
>
> 요청1
>
> ---
>
> GET /star.jpg

> 서버
>
> **start-line**
>
> HTTP/1.1 **200 OK**
>
> ---
>
> **header**
>
> Content-Type: image/jpeg
>
> cache-control: max-age=60
>
> **Last-Modified: 2020년 11월 10일 10:00:00**
>
> Content-Length: 34012
>
> ---
>
> **body**
>
> ````text
> lkj123kljoiasudlkjaweioluywlnfdo912u34ljko98udjkl
> ````

> 브라우저 캐시
>
> ---
>
> **60초 유효**
>
> ( 응답 결과를 캐시에 저장 )
> 
> **데이터 최종 수정일: 2020년 11월 10일 10:00:00**

- 이렇게 저장해두고, 60초 안이면 당연히 브라우저 캐시를 사용한다
- 그런데 만약 60초가 지난다면?

---

### 검증 헤더 추가
#### 두 번째 요청 - 캐시 시간 초과

- 검증헤더( Last-Modified )가 브라우저 캐시에 존재할시 HTTP 요청을 보낼때,


- if-modified-since 라는 요청 헤더를 붙인 후, 날짜를 담는다


- 그러면 서버에서 요청을 받았을때, 해당 데이터 최종수정일을 비교해 데이터가 바뀌었나 바뀌지 않았나를 **검증할 수 있다**

> 웹 브라우저
>
> 요청2
>
> ---
>
> GET /star.jpg
> 
> **if-modified-since: 2020년 11월 10일 10:00:00**
> 
> ( 캐시가 가지고 있는, 데이터 최종 수정일 )

> 브라우저 캐시
>
> ---
>
> **60초 초과**
>
> **데이터 최종 수정일: 2020년 11월 10일 10:00:00**

-->

> 서버
>
> ---
> 
> star.jpg
>
> **데이터 최종 수정일: 2020년 11월 10일 10:00:00**

- 데이터의 **날짜를 보고 판단 가능**

---

### 검증 헤더 추가
#### 첫 번째 요청


> 웹 브라우저
>
> 요청1
>
> ---
>
> GET /star.jpg

> 서버
>
> **start-line**
>
> HTTP/1.1 **200 OK**
>
> ---
>
> **header**
>
> Content-Type: image/jpeg
>
> cache-control: max-age=60
>
> **Last-Modified: 2020년 11월 10일 10:00:00**
>
> Content-Length: 34012
>
> ---
>
> **body**
>
> ````text
> lkj123kljoiasudlkjaweioluywlnfdo912u34ljko98udjkl
> ````

> 브라우저 캐시
>
> ---
>
> **60초 유효**
>
> ( 응답 결과를 캐시에 저장 )
>
> **데이터 최종 수정일: 2020년 11월 10일 10:00:00**

- 이렇게 저장해두고, 60초 안이면 당연히 브라우저 캐시를 사용한다
- 그런데 만약 60초가 지난다면?

---

### 검증 헤더 추가
#### 두 번째 요청 - 캐시 시간 초과

- 만약 들어온 요청을보고 수정이 되지 않았다고 하면 서버에서는 다시 이렇게 보낸다

> 웹 브라우저

> 서버
>
> **start-line**
>
> HTTP/1.1 **304 Not Modified**
>
> ---
>
> **header**
>
> Content-Type: image/jpeg
>
> cache-control: max-age=60
>
> **Last-Modified: 2020년 11월 10일 10:00:00**
>
> Content-Length: 34012
>
> **( HTTP Body 가 없다 )**

<-- star.jpg

( _**0.1M 전송**_ )

( _HTTP Body 전송 X_ )

( 데이터가 _** 1.1M**_ 라고 가정했을 시,
  HTTP 헤더 : **0.1M** , HTTP 바디 : **1.0M** )

> 브라우저 캐시
>
> ---
>
> **60초 유효**
> 
> ( 응답 결과를 재사용, 헤더 데이터 갱신 )
>
> **데이터 최종 수정일: 2020년 11월 10일 10:00:00**

- Body 를 다빼고, 헤더만 전송하게 되면 네트워크 부하가 확 줄어들게 된다


- cache 가 바뀌지 않았기 때문에 써도 된다라고 판단하고, 
  - cache-control 값을 갱신하고,
  - cache 를 다시 세팅하게 된다

---

### 검증 헤더 추가
#### 두 번째 요청 - 캐시 시간 초과

> 웹 브라우저

> 브라우저 캐시
> 
> ---
> 
> **60초 유효**
> 
> ( 캐시에서 조회 )
> 
> **데이터 최종 수정일: 2020년 11월 10일 10:00:00**

<--

- 이렇게 다시 캐시에서 불러와 쓰게 된다

---

### 검증 헤더와 조건부 요청
#### 정리

- 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면


- 304 Not Modified + 헤더 메타 정보만 응답( 바디 X )


- 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신


- 클라이언트는 캐시에 저장되어 있는 데이터 재활용


- 결과적으로 **네트워크 다운로드가 발생하지만** 용량이 적은 **헤더 정보만 다운로드**


- **매우 실용적인 해결책**

  - **Last-Modified** : 검증헤더
  - **if-modified-since** : 조건부 요청
  - 이 두개를 조합해서 서버에서 진짜 캐시가 변경되었는지를 확인할 수 있다
    - ( 전송 용량을 줄일 수 있음 )
  - 따라서, 웹브라우저들은 대부분 이 매커니즘을 사용하고 있다


- **브라우저 개발자 도구 Network 창에서 Status 색이 연한 것은 cache 에서 불러온 것이다**
  - 해당소스를 더블클릭해 경로로 들어가보면 , State 304, 요청헤더에 if-modified-since 가 존재하는 것을 볼 수 있다 
  - ( 새로고침하면 브라우저가 다시 서버에 요청하기 때문에 확인할 수 있다 )
